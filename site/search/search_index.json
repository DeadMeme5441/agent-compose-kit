{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Agent Compose Kit","text":"<p>Agent Compose Kit is a Python library that turns YAML into runnable agent systems on top of Google ADK. It\u2019s programmatic-only: no server, no CLI \u2014 just focused, composable building blocks for your own CLI, TUI, or Web app.</p> <p>Highlights - Config \u2192 Objects: validate YAML and construct ADK services, tools, and agents. - Conservative defaults: in-memory fallbacks when required params are missing. - Registries-first: enumerate tools/APIs/agents by id/group without building a Runner. - Graph builder: produce nodes/edges for your UI, no HTTP needed.</p> <p>What this repo is not - It does not ship a web server or UI. Use it inside your own app. For server helpers, see google-adk-extras.</p> <p>Quick links - Installation: Install - Config schema: Configuration - Services: Services - Tools &amp; Registries: Tools, Registries - Agents &amp; Workflows: Agents - Graph builder: Graph - Programmatic API: Public API - End-to-end: Examples</p> <p>Requirements - Python 3.12+ - google-adk and google-adk-extras (installed automatically via pip when you add this package). Optional extras like MCP/OpenAPI are guarded.</p>"},{"location":"agents/","title":"Agents","text":"<p>LlmAgent from string model <pre><code>agents:\n  - name: planner\n    model: gemini-2.0-flash\n    instruction: Plan tasks and call tools.\n</code></pre></p> <p>LiteLLM model mapping with provider defaults <pre><code>model_providers:\n  openai:\n    api_key: ${OPENAI_API_KEY}\n\nagents:\n  - name: planner\n    model:\n      type: litellm\n      model: openai/gpt-4o-mini\n</code></pre></p> <p>Sub-agents &amp; workflows <pre><code>agents:\n  - name: a\n    model: gemini-2.0-flash\n  - name: b\n    model: gemini-2.0-flash\n    sub_agents: [a]\n\nworkflow: {type: sequential, nodes: [a, b]}\n</code></pre></p> <p>A2A remote agents (agent cards) <pre><code>a2a_clients:\n  - id: remote\n    agent_card_url: https://host:8000/a2a/hello/.well-known/agent-card.json\n\nagents:\n  - name: remote\n    kind: a2a_remote\n    client: remote\n</code></pre></p> <p>Notes - A2A prefers agent cards (AgentCard or URL). The legacy <code>url</code> field is still accepted but is treated as a card URL. - Advanced options (planner, code executor, structured schemas) are optional and guarded.</p>"},{"location":"config/","title":"Configuration","text":"<p>Configs are Pydantic-based and support environment variable interpolation.</p> <p>Load and validate <pre><code>from pathlib import Path\nfrom agent_compose_kit.config.models import load_config_file\n\ncfg = load_config_file(Path(\"configs/app.yaml\"))\n</code></pre></p> <p>Top-level shape (AppConfig) - services: <code>session_service</code>, <code>artifact_service</code>, <code>memory_service</code> \u2014 each accepts a dict or a URI string. - model_providers: defaults merged into LiteLLM model definitions. - toolsets: shared toolsets reusable by agents. - agents, groups, workflow: define agent graph and composition. - registries: <code>tools_registry</code>, <code>agents_registry</code>, <code>mcp_registry</code>, <code>openapi_registry</code>. - a2a_clients: remote agent clients (agent card URLs). - runtime: ADK RunConfig tuning (streaming, limits). - global_instruction: optional instruction applied to the root agent at runtime.</p> <p>Environment interpolation - <code>${VAR}</code> and <code>$VAR</code> sequences are substituted from the process env.</p> <p>Service URIs - Sessions: <code>sqlite:///...</code>, <code>postgresql://...</code>, <code>mysql://...</code>, <code>redis://host:port/db</code>, <code>mongodb://...</code>, <code>yaml://path</code>, <code>memory:</code> - Artifacts: <code>file://path</code>, <code>s3://bucket/prefix</code>, <code>mongodb://...</code>, <code>sqlite:///...</code> - Memory: <code>redis://...</code>, <code>mongodb://...</code>, <code>sqlite:///...</code>, <code>yaml://...</code>, <code>memory:</code></p> <p>Programmatic parsing <pre><code>from agent_compose_kit.config.models import parse_service_uri\n\ncfg = parse_service_uri(\"session\", \"sqlite:///./sessions.db\")\n</code></pre></p>"},{"location":"examples/","title":"End-to-end Examples","text":""},{"location":"examples/#minimal-yaml-runner","title":"Minimal YAML + runner","text":"<pre><code>services:\n  session_service: \"sqlite:///./sessions.db\"\n  artifact_service: \"file://./artifacts\"\n\nagents:\n  - name: planner\n    model: gemini-2.0-flash\n    instruction: You are a helpful planner.\n\nworkflow:\n  type: sequential\n  nodes: [planner]\n</code></pre> <pre><code>from pathlib import Path\nfrom agent_compose_kit.config.models import load_config_file\nfrom agent_compose_kit.runtime.supervisor import build_run_config\nfrom agent_compose_kit.api.public import SystemManager, SessionManager, run_text, event_to_minimal_json\n\ncfg = load_config_file(Path(\"./configs/app.yaml\"))\nsm = SystemManager(base_dir=Path(\".\"))\nroot = sm.select_root_agent(cfg)\nrunner, _ = sm.build_runner(cfg, root_agent=root)\n\nimport asyncio\n\nasync def main():\n    sess = await SessionManager(runner).get_or_create(user_id=\"u1\")\n    async for ev in run_text(runner=runner, user_id=\"u1\", session_id=sess.id, text=\"hello\"):\n        print(event_to_minimal_json(ev))\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/#tools-via-registries","title":"Tools via registries","text":"<pre><code>tools_registry:\n  tools:\n    - {id: util.add, type: function, ref: tests.helpers:sample_tool}\n  groups:\n    - {id: essentials, include: [util.add]}\n\nagents_registry:\n  agents:\n    - {id: calc, name: calculator, model: gemini-2.0-flash, tools: [{use: 'registry:util.add'}]}\n  groups:\n    - {id: core, include: [calc]}\n</code></pre> <pre><code>from agent_compose_kit.tools.builders import build_tool_registry_from_config\nfrom agent_compose_kit.agents.builders_registry import build_agent_registry_from_config\n\ntool_reg = build_tool_registry_from_config(cfg, base_dir=\".\")\nagent_reg = build_agent_registry_from_config(cfg, base_dir=\".\", provider_defaults=cfg.model_providers, tool_registry=tool_reg)\nroot = agent_reg.get_group(\"core\")[0]\n</code></pre>"},{"location":"examples/#a2a-remote-agent-by-agent-card","title":"A2A remote agent by agent card","text":"<pre><code>a2a_clients:\n  - id: remote\n    agent_card_url: https://host:8000/a2a/hello/.well-known/agent-card.json\n\nagents:\n  - name: remote\n    kind: a2a_remote\n    client: remote\n</code></pre>"},{"location":"faq/","title":"Frequently Asked Questions","text":"<p>Does this library include a server? - No. It is programmatic-only. If you need a hosted API, use google-adk-extras to build a FastAPI app and wire your agents.</p> <p>Do I need google-adk-extras? - Yes for most storage/IO backends (Redis, Mongo, SQL, S3, local folders, YAML). It is a dependency of this package and gets installed automatically, but you still need to configure your URIs/secrets.</p> <p>How do I connect to MCP or OpenAPI toolsets? - MCP and OpenAPI adapters come from ADK. This library builds and caches toolsets. Ensure the corresponding ADK components are installed and available.</p> <p>Can I fetch OpenAPI specs by URL? - Yes via OpenAPIRegistry only, and only when the hostname is allowlisted to avoid surprises. Inline/path specs are always supported.</p> <p>Can I enumerate agents/tools without building a Runner? - Yes. Use registries and their <code>list_*</code> helpers.</p>"},{"location":"graph/","title":"Graph","text":"<p>Produce a simple system graph for UIs \u2014 no HTTP server required.</p> <pre><code>from pathlib import Path\nfrom agent_compose_kit.config.models import load_config_file\nfrom agent_compose_kit.graph.build import build_system_graph\n\ncfg = load_config_file(Path(\"configs/app.yaml\"))\ng = build_system_graph(cfg)\nprint(g[\"nodes\"], g[\"edges\"])  # nodes/edges dicts\n</code></pre> <p>Nodes - Inline agents and groups - Registry agents and groups (<code>registry:*</code> node ids)</p> <p>Edges - Sub-agent wiring, group membership, workflow order</p>"},{"location":"install/","title":"Installation","text":"<p>Agent Compose Kit is published on PyPI. It depends on Google ADK and google-adk-extras. We recommend using <code>uv</code> for reliable, fast environments.</p> <p>Using uv <pre><code>uv add agent-compose-kit\n</code></pre></p> <p>Using pip <pre><code>pip install agent-compose-kit\n</code></pre></p> <p>Optional dependencies - MCP stdio support: <code>uv add agent-compose-kit[tools]</code> (installs <code>mcp</code>) - Docs (for contributors): <code>uv add --dev agent-compose-kit[docs]</code></p> <p>Python compatibility - Python 3.12+</p> <p>Notes - Certain backends (Redis, Mongo, SQL, S3) require google-adk-extras at runtime. It is listed in this package\u2019s dependencies and will be installed automatically, but you must still provide valid connection details at runtime.</p>"},{"location":"public_api/","title":"Public API","text":"<p>Use these helpers to integrate quickly without dealing with low-level plumbing.</p> <p>SystemManager <pre><code>from pathlib import Path\nfrom agent_compose_kit.api.public import SystemManager\n\nsm = SystemManager(base_dir=Path(\"./systems/my_system\"))\ncfg = sm.load(\"config.yaml\")\nroot = sm.select_root_agent(cfg)\nrunner, resources = sm.build_runner(cfg, root_agent=root)\n</code></pre></p> <p>SessionManager <pre><code>from agent_compose_kit.api.public import SessionManager\nsess_mgr = SessionManager(runner)\nsession = await sess_mgr.get_or_create(user_id=\"u1\")\n</code></pre></p> <p>run_text <pre><code>from agent_compose_kit.api.public import run_text, event_to_minimal_json\n\nasync for ev in run_text(runner=runner, user_id=\"u1\", session_id=session.id, text=\"hello\"):\n    print(event_to_minimal_json(ev))\n</code></pre></p> <p>Notes - <code>SystemManager.select_root_agent</code> prefers agents_registry when provided. - <code>event_to_minimal_json</code> serializes events for light UIs; extend as needed for your app.</p>"},{"location":"registries/","title":"Registries","text":"<p>ToolRegistry (inline) <pre><code>from pathlib import Path\nfrom agent_compose_kit.config.models import load_config_file\nfrom agent_compose_kit.tools.builders import build_tool_registry_from_config\n\ncfg = load_config_file(Path(\"configs/app.yaml\"))\ntool_reg = build_tool_registry_from_config(cfg, base_dir=\".\")\nprint(tool_reg.list_tool_ids())\n</code></pre></p> <p>McpRegistry / OpenAPIRegistry <pre><code>from agent_compose_kit.tools.builders import build_mcp_registry_from_config, build_openapi_registry_from_config\n\nmcp_reg = build_mcp_registry_from_config(cfg, base_dir=\".\")\nopenapi_reg = build_openapi_registry_from_config(cfg, base_dir=\".\")\n</code></pre></p> <p>AgentRegistry <pre><code>from agent_compose_kit.agents.builders_registry import build_agent_registry_from_config\n\nagent_reg = build_agent_registry_from_config(cfg, base_dir=\".\", provider_defaults=cfg.model_providers, tool_registry=tool_reg)\nroot = agent_reg.get_group(\"core\")[0]\n</code></pre></p> <p>Groups - Each registry supports simple groups (id \u2192 include list). - Use <code>list_*</code> helpers to enumerate ids/groups before resolution.</p> <p>Notes - OpenAPI registry enforces a strict allowlist for fetching specs via URL. - Call <code>close_all()</code> on ToolRegistry or registries that hold long-lived connections when your app shuts down.</p>"},{"location":"services/","title":"Services","text":"<p>The factories in <code>agent_compose_kit.services.factory</code> build ADK services. They\u2019re conservative: if required params are missing, they return in-memory implementations.</p> <p>SessionService <pre><code>from agent_compose_kit.services.factory import build_session_service\n\nsvc = build_session_service(\"sqlite:///./sessions.db\")  # or dict config\n</code></pre></p> <p>ArtifactService <pre><code>from agent_compose_kit.services.factory import build_artifact_service\n\nart = build_artifact_service(\"file://./artifacts\")\n</code></pre></p> <p>MemoryService (optional) <pre><code>from agent_compose_kit.services.factory import build_memory_service\n\nmem = build_memory_service(\"memory:\")  # or redis/mongo/sql/yaml\n</code></pre></p> <p>Backends - In-memory (default fallbacks) - Redis, MongoDB, SQL (via google-adk-extras) - YAML file stores (sessions/memory) - Artifacts: local folder, S3, MongoDB, SQL</p> <p>Notes - Missing or incomplete params \u2192 in-memory fallback. - No GCS support in this library (keep scope aligned with extras).</p>"},{"location":"tools/","title":"Tools","text":"<p>Function tools <pre><code>agents:\n  - name: calc\n    model: gemini-2.0-flash\n    tools:\n      - {type: function, ref: tests.helpers:sample_tool, name: add}\n</code></pre></p> <p>MCP toolsets (stdio/SSE/HTTP) <pre><code>toolsets:\n  fs_tools:\n    type: mcp\n    mode: stdio\n    command: npx\n    args: [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"./sandbox\"]\n    tool_filter: [list_directory, read_file]\n</code></pre></p> <p>OpenAPI toolsets <pre><code>agents:\n  - name: api_caller\n    model: gemini-2.0-flash\n    tools:\n      - type: openapi\n        spec: {path: ./specs/petstore.yaml}\n        # spec_type inferred from extension; or set explicitly: json|yaml\n</code></pre></p> <p>Registry references in tools <pre><code>agents:\n  - name: rich_tools\n    model: gemini-2.0-flash\n    tools:\n      - {use: 'mcp:files'}\n      - {use: 'openapi:petstore'}\n</code></pre></p> <p>Notes - MCP/OpenAPI support requires corresponding ADK components; imports are guarded. - OpenAPI via URL requires allowlisted host in openapi_registry; inline/path supported directly.</p>"}]}